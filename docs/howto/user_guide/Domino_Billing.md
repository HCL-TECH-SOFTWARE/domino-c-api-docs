##### Chapter 13-3
##### Domino Billing

<b><font size="5" color="#000080">Introduction</font></b><br>
<br>
Domino servers can track usage activity and support a billing process.  You can configure the server to track, record, and store usage details for the following Domino activities. Each type of activity is designated by a Domino billing class. <br>
<br>
<br>

<table width="100%" border="1">
<tr valign="top"><td width="22%"><b><i><font size="2">Activity </font></i></b></td><td width="39%"><b><i><font size="2">Description</font></i></b></td><td width="39%"><b><i><font size="2">Billing Class</font></i></b></td></tr>

<tr valign="top"><td width="22%"><font size="2">Agent</font></td><td width="39%"><font size="2">Tracks the user, task, and database activity related to agent execution on the billing server.</font></td><td width="39%"><font size="2">BILL_CLASS_AGENT</font></td></tr>

<tr valign="top"><td width="22%"><font size="2">Database</font></td><td width="39%"><font size="2">Tracks each database opened and closed on the billing server. Database billing tracks the amount of elapsed time a database is open per session.</font></td><td width="39%"><font size="2">BILL_CLASS_DATABASE</font></td></tr>

<tr valign="top"><td width="22%"><font size="2">Document</font></td><td width="39%"><font size="2">Tracks access for documents in a database that contain hidden BILLCHARGEREAD or BILLCHARGEWRITE fields and associates a cost charge with the action.</font></td><td width="39%"><font size="2">BILL_CLASS_DOCUMENT</font></td></tr>

<tr valign="top"><td width="22%"><font size="2">HttpRequest</font></td><td width="39%"><font size="2">Tracks Web server requests.</font></td><td width="39%"><font size="2">BILL_CLASS_HTTPREQUEST</font></td></tr>

<tr valign="top"><td width="22%"><font size="2">Mail</font></td><td width="39%"><font size="2">Tracks the mailing of documents. When you enable mail billing, mail messages leaving the billing server mailbox are tracked and recorded in mail billing records. </font></td><td width="39%"><font size="2">BILL_CLASS_MAIL</font></td></tr>

<tr valign="top"><td width="22%"><font size="2">Replication</font></td><td width="39%"><font size="2">Tracks replication of databases when initiated by the billing server with another Domino server.</font></td><td width="39%"><font size="2">BILL_CLASS_REPLICATION</font></td></tr>

<tr valign="top"><td width="22%"><font size="2">Session</font></td><td width="39%"><font size="2">Tracks network traffic that a user generates during a session. For example, when the user logs onto the server, Domino records any network-related activity needed to complete the transaction.</font></td><td width="39%"><font size="2">BILL_CLASS_SESSION</font></td></tr>
</table>

<ul>
<ul><br>
</ul>
</ul>
There are two components to Domino billing:
<ul>
<ul><br>
<b>Domino server</b> <br>
You can enable Domino servers to track specific activities for billing. You select the activities you want the server to track by adding classes to the BillingClass setting in the notes.ini file. As billable activities occur, the server adds this information to the billing message queue. We refer to a Domino server with the billing process enabled as a &quot;billing server.&quot;<br>
<br>
For more information, see the <i>Domino Administration Help </i>documentaiton<i>.</i><br>
</ul>
</ul>
<b>Billing server task</b>
<ul>
<ul>The billing server add-in task collects billing information by periodically polling the message queue and removing billing records. You can store this data in either a Billing database (billing.nsf) or a binary file (billing.nbf) for later retrieval. </ul>
</ul>

<ul>
<ul>For more information, see the<i> Domino Administration Help </i>documentation.</ul>
</ul>
<br>
The remainder of this chapter describes the billing message and record structures and describes how to design and program a custom billing server and billing add-in server task using the HCL C API for Domino and Notes toolkit.<br>
<br>
<br>
<b><font size="5" color="#000080">Anatomy of a Billing Message</font></b><br>
<br>
The billing message queue is the heart of the billing process. All billing messages generated by the billing server are written to this queue. In turn, the billing server task retrieves the messages from the queue for further processing. The HCL C API for Domino and Notes provides functions for reading from and writing to the billing message queue and also defines the data types and symbols that comprise the contents of the message.<br>
<br>
A billing message is defined by a general purpose data structure that can be applied to all supported billing types. It consists of header information that defines the attributes of the record, followed by the billing record itself. The following sections describe the default data types and symbols that comprise a billing message and support the billing process, as defined in the billing include file billing.h.<br>
<br>
<b>Billing Message Queue</b><br>
<br>
<tt><font size="2">#define BILL_QUEUE_NAME &nbsp; &quot;MQ$BILLING&quot; &nbsp; </font></tt><br>
<br>
This is the default billing message queue. The billing server and billing server add-in tasks use this literal when calling the C API to retrieve an open message queue handle, which subsequent message queue reads and writes can then use.<br>
<br>
<b>Billing Classes</b><br>
<br>
<tt><font size="2">#define BILL_CLASS_SESSION &nbsp; &nbsp; &nbsp; 0x00000001 &nbsp;/* Session */<br>
#define BILL_CLASS_REPLICATION &nbsp; 0x00000002 &nbsp;/* Replication*/<br>
#define BILL_CLASS_DOCUMENT &nbsp; &nbsp; &nbsp;0x00000004 &nbsp;/* Document Charge */<br>
#define BILL_CLASS_MAIL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x00000008 &nbsp;/* Mail */<br>
#define BILL_CLASS_DATABASE &nbsp; &nbsp; &nbsp;0x00000010 &nbsp;/* Database */</font></tt><br>
<tt><font size="2">#define BILL_CLASS_AGENT &nbsp; &nbsp; &nbsp; &nbsp; 0x00000020 &nbsp;/* Agent */</font></tt><br>
<tt><font size="2">#define BILL_CLASS_HTTPREQUEST &nbsp; 0x00000040 &nbsp;/* Http Request */</font></tt><br>
<br>
These constant values represent the different billing classes supported by the HCL Domino Server Billing Process. The billing server uses these values to interpret the currently active classes of supported billing on the Domino server, as returned by the API function BillingGetClass. The billing add-in also uses these values when reading the billing message header structures to determine the type of reporting to perform.<br>
<br>
<b>Billing Structure Types</b><br>
<br>
<tt><font size="2">#define BILL_SESSIONREC &nbsp; &nbsp; &nbsp;1 &nbsp;/* Session Record Type */<br>
#define BILL_REPLREC &nbsp; &nbsp; &nbsp;1001 &nbsp;/* Replication Record Type */<br>
#define BILL_DOCCHARGE &nbsp; &nbsp;2001 &nbsp;/* Document Record Type */<br>
#define BILL_MAILREC &nbsp; &nbsp; &nbsp;3001 &nbsp;/* Mail Record Type */<br>
#define BILL_DBREC &nbsp; &nbsp; &nbsp; &nbsp;4001 &nbsp;/* Database Record Type*/</font></tt><br>
<tt><font size="2">#define BILL_AGENTREC &nbsp; &nbsp; 5001 &nbsp;/* Agent Record Type */</font></tt><br>
<tt><font size="2">#define BILL_HTTPREQREC &nbsp; 6001 &nbsp;/* Http Request Record Type */</font></tt><br>
<br>
These constant values define the types of billing record structures that a billing message can contain. By default, there is one billing structure type per billing class, although you can extend this for customized billing structure types. There is always a corresponding billing record structure for each billing structure type. The billing structure type is part of the billing message header information that the billing server writes and the billing add-in reads.<br>
<br>
<b>Session and Database Billing Actions </b><br>
<br>
<tt><font size="2">#define BILL_SESSION_START &nbsp; 1 &nbsp; &nbsp;/* Session Start record */<br>
#define BILL_DB_OPEN &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp;/* DB Open */<br>
#define BILL_DB_CLOSE &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp;/* DB Close by User &nbsp;*/<br>
#define BILL_SESSION_STAMP &nbsp; 4 &nbsp; &nbsp;/* Periodic session record */<br>
#define BILL_DB_STAMP &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp;/* Periodic database stamp */<br>
#define BILL_DB_CLOSE_END &nbsp; &nbsp;6 &nbsp; &nbsp;/* Physical close when session terminates. */<br>
#define BILL_SESSION_END &nbsp; &nbsp; 255 &nbsp;/* Session End */</font></tt><br>
<br>
These constant values define the types of actions that the session and database activity billing track. The billing actions are part of the session and database billing record structures that the billing server writes and the billing add-in reads.<br>
<br>
<b>Document Billing Charges</b><br>
<br>
<tt><font size="2">#define BILLCHARGEREAD &nbsp; &nbsp;1 &nbsp; /* Document Read charge */ <br>
#define BILLCHARGEWRITE &nbsp; 2 &nbsp; /* Document Write charge */</font></tt><br>
<br>
These constant values define the type of access charge actions that are tracked when documents are read or written in a database on the billing server. This document charge is part of the document billing record structure that the billing server writes and the billing add-in reads.<br>
<br>
<b>Billing Record Structures</b><br>
<br>
<tt><font size="2">/* session billing */</font></tt><br>
<tt><font size="2">typedef struct<br>
{<br>
 &nbsp; SESSIONID &nbsp; SessionID; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Session ID */<br>
 &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp;Action; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Start, Stamp, End */<br>
 &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp;Username[MAXUSERNAME+1]; &nbsp;/* Username */<br>
 &nbsp; DWORD &nbsp; &nbsp; &nbsp; BytesIn; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Bytes read thus far in this session */<br>
 &nbsp; DWORD &nbsp; &nbsp; &nbsp; BytesOut; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Bytes written thus far in this session */<br>
 &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp;NetAdr[MAXNETADR]; &nbsp; &nbsp; &nbsp; &nbsp;/* IP Address of client */<br>
} SESSIONREC;</font></tt><br>
<br>
<tt><font size="2">/* database billing */</font></tt><br>
<tt><font size="2">typedef struct		<br>
{<br>
 &nbsp; SESSIONID &nbsp; SessionID; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Session ID */<br>
 &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp;Action; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* DbOpen, Stamp, DbClose */<br>
 &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp;Username[MAXUSERNAME+1]; &nbsp; /* Username */<br>
 &nbsp; DWORD &nbsp; &nbsp; &nbsp; DBOpenTime; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* DB Open Time */<br>
 &nbsp; TIMEDATE &nbsp; &nbsp;ReplicaID; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Replica ID of Database opened or closed*/<br>
} DBREC;<br>
</font></tt><br>
<tt><font size="2">/* replication billing */ &nbsp; &nbsp; <br>
typedef struct			<br>
{<br>
 &nbsp; SESSIONID &nbsp; SessionID; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Session ID */<br>
 &nbsp; DWORD &nbsp; &nbsp; &nbsp; BytesIn; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Bytes read to replicate this database. */<br>
 &nbsp; DWORD &nbsp; &nbsp; &nbsp; BytesOut; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Bytes written to replicate this database. */<br>
 &nbsp; TIMEDATE &nbsp; &nbsp;ReplicaID; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Replica ID */<br>
 &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp;Source[MAXUSERNAME+1]; &nbsp; &nbsp; &nbsp; /* Replication source */<br>
 &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp;Destination[MAXUSERNAME+1]; &nbsp;/* Replication Destination */<br>
 &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp;Priority; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Replication priority*/<br>
} REPLREC;<br>
</font></tt><br>
<tt><font size="2">/* document charge billing */</font></tt><br>
<tt><font size="2">typedef struct<br>
{<br>
 &nbsp; WORD &nbsp; &nbsp; &nbsp; Type; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* $ChargeWrite or $ChargeRead */<br>
 &nbsp; TIMEDATE &nbsp; ReplicaID; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Database replica id */<br>
 &nbsp; char &nbsp; &nbsp; &nbsp; Username[MAXUSERNAME+1]; &nbsp;/* Username */<br>
 &nbsp; OID &nbsp; &nbsp; &nbsp; &nbsp;OriginatorID; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Universally unique Note ID of document */<br>
 &nbsp; NUMBER &nbsp; &nbsp; Charge; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Value stored in $Charge Field */<br>
} DOCUMENT;</font></tt><br>
<br>
<tt><font size="2">/* mail billing */ </font></tt><br>
<tt><font size="2">typedef struct<br>
{<br>
 &nbsp; char &nbsp; &nbsp; &nbsp; FormType[DESIGN_NAME_MAX]; &nbsp;/* Type of Form */<br>
 &nbsp; OID &nbsp; &nbsp; &nbsp; &nbsp;OriginatorID; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Message Id */<br>
 &nbsp; UNID &nbsp; &nbsp; &nbsp; OrigMessageID; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* $Ref if message is split */ &nbsp;<br>
 &nbsp; DWORD &nbsp; &nbsp; &nbsp;MessageSize; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Size of message */<br>
 &nbsp; char &nbsp; &nbsp; &nbsp; HopName[MAXUSERNAME+1]; &nbsp; &nbsp; /* Next Server Name in route */<br>
 &nbsp; WORD &nbsp; &nbsp; &nbsp; Priority; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Delivery priority */<br>
 &nbsp; WORD &nbsp; &nbsp; &nbsp; RoutingState; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Delivery state of message */<br>
 &nbsp; WORD &nbsp; &nbsp; &nbsp; Report; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Delivery report request */<br>
 &nbsp; char &nbsp; &nbsp; &nbsp; Originator[MAXUSERNAME+1]; &nbsp;/* From: */<br>
 &nbsp; WORD &nbsp; &nbsp; &nbsp; RecipientCount; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Recipient count */<br>
 &nbsp; WORD &nbsp; &nbsp; &nbsp; RecipientSize; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Recipients string size */<br>
 &nbsp; TIMEDATE &nbsp; PostedDate; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Date message was posted to router mailbox */<br>
/* Recipients char string follows structure. &nbsp;This is a packed character array of recipient</font></tt><br>
<tt><font size="2">&nbsp; &nbsp;names delimited by a comma. &nbsp;The array is not NULL-terminated therefore, the RecipientSize</font></tt><br>
<tt><font size="2">&nbsp; &nbsp;field is used to traverse the array */<br>
} MAILREC;</font></tt><br>
<br>
<tt><font size="2">/* agent billing */</font></tt><br>
<tt><font size="2">typedef struct<br>
{<br>
 &nbsp; WORD &nbsp; &nbsp; &nbsp; ULen; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* UserName Length */<br>
 &nbsp; WORD &nbsp; &nbsp; &nbsp; TLen; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* TaskName Length */<br>
 &nbsp; WORD &nbsp; &nbsp; &nbsp; DLen; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* DatabaseName Length */<br>
 &nbsp; DWORD &nbsp; &nbsp; &nbsp;ElapsedRunTime; &nbsp;/* Elapsed run-time for agent */<br>
 &nbsp; DWORD &nbsp; &nbsp; &nbsp;Flags; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Agent Flags: BILL_AGENT_XXX */<br>
/* UserName, TaskName, Database Name strings follows structure */<br>
} AGENTREC;</font></tt><br>
<br>
<tt><font size="2">/* http request billing */</font></tt><br>
<tt><font size="2">typedef struct<br>
{<br>
 &nbsp; DWORD	HttpContentLength;			/* Content Length send/received to/from client */<br>
 &nbsp; DWORD	HttpReqTimeMs;				/* Number of milliseconds to process request */<br>
 &nbsp; DWORD	HttpStatusCode;				/* Status code returned by the server */<br>
 &nbsp; WORD	HttpTimeStampOffset;		/* Offset to http time stamp in a string format */<br>
 &nbsp; WORD	HttpAuthUserOffset;			/* Offset to Authenticated User string */<br>
 &nbsp; WORD	HttpPartnerOffset;			/* Offset to remote machine name string */<br>
 &nbsp; WORD	HttpRefererOffset;			/* Offset to refering URL string */<br>
 &nbsp; WORD	HttpServerAddrOffset;		/* Offset to connection IP address */<br>
 &nbsp; WORD	HttpUserAgentOffset;		/* Offset to user agent string */<br>
 &nbsp; WORD	HttpRequestLineOffset;		/* Offset to Request line string */<br>
 &nbsp; WORD	HttpContentTypeOffset;		/* Offset to content type string */<br>
/* Time Stamp, AuthUser, Partner and other strings follow */<br>
} HTTPREQREC;</font></tt><br>
<br>
The above structure definitions correspond to the billing record structures for the billing activities tracked by the default HCL Domino Server Billing Process. They contain all the information pertinent to the billing class and structure type and enough to apportion a service bill to the consumer. For more information on the elements of each billing record structure, refer to the <i>Reference. </i>The billing server writes the billing record structure information and the billing add-in reads it.<br>
<br>
<b>Billing Record</b><br>
<br>
<tt><font size="2">typedef union<br>
{<br>
 &nbsp; SESSIONREC &nbsp; sess; &nbsp; &nbsp; &nbsp; &nbsp;/* session billing record */<br>
 &nbsp; REPLREC &nbsp; &nbsp; &nbsp;repl; &nbsp; &nbsp; &nbsp; &nbsp;/* replication billing record */<br>
 &nbsp; DOCUMENT &nbsp; &nbsp; doc; &nbsp; &nbsp; &nbsp; &nbsp; /* document charge billing record */<br>
 &nbsp; MAILREC &nbsp; &nbsp; &nbsp;mail; &nbsp; &nbsp; &nbsp; &nbsp;/* mail billing record */<br>
 &nbsp; DBREC &nbsp; &nbsp; &nbsp; &nbsp;db; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* database billing record */</font></tt><br>
<tt><font size="2">&nbsp; &nbsp;AGENTREC &nbsp; &nbsp; agent; &nbsp; &nbsp; &nbsp; /* agent billing record */</font></tt><br>
<tt><font size="2">&nbsp; &nbsp;HTTPREQREC &nbsp; HttpRequest; /* http request billing record */</font></tt><br>
<tt><font size="2">/* extend for custom billing record structures */<br>
} BILLREC;<br>
</font></tt><br>
As defined above, the billing record is the union of the default billing record structures plus any customized billing record structures that you define. This structure is contained in the billing message immediately after the billing message header information. Since a billing message is based on a particular billing class and structure type, only one billing record structure per billing message contains valid information. The billing server and billing server add-in task<font color="#FF0000"> </font>determine the billing record structure to use while writing or reading a billing record. <br>
<br>
<b>Billing Message</b><br>
<br>
<tt><font size="2">typedef struct<br>
{<br>
 &nbsp; WORD &nbsp; &nbsp; &nbsp; Len; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* length of the billing message */<br>
 &nbsp; WORD &nbsp; &nbsp; &nbsp; StructType; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* billing record structure type */<br>
 &nbsp; DWORD &nbsp; &nbsp; &nbsp;Class; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* billing class */<br>
 &nbsp; char &nbsp; &nbsp; &nbsp; ServerName[MAXUSERNAME+1]; &nbsp;/* billing server name */<br>
 &nbsp; TIMEDATE &nbsp; TimeStamp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* timestamp of transaction */<br>
 &nbsp; BILLREC &nbsp; &nbsp;rec; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* the billing record */<br>
} BILLMSG;</font></tt><br>
<br>
The above structure defines the billing message that is written to and read from the billing message queue. The first five elements comprise the billing message header and are followed by the billing record union. The billing header elements provide programmatic information specific to the billing record. The header lets programmers filter billing records for particular billing classes or structure types to be processed in their applications.  <br>
<br>
The billing server is responsible for constructing the billing message. Typically, this task uses the API function BillingGetClass to check to see if a particular billing class is configured for the Domino server. Then, if the class is configured, the billing server uses the API function BillingWrite to appropriately construct the billing message and write it to the billing message queue.  The billing server task uses API message queue functions such as MQGet to read the billing message from the queue and formats the information into the desired report format.<br>
<br>
<br>
<b><font size="5" color="#000080">Writing a Billing Message (Billing Server Sample)</font></b><br>
<br>
In designing a custom billing server, you must first define any new data type and symbols related to the activity being tracked. At a minimum, this involves defining a new billing structure type and billing record structure for each unique billing activity and extending the billing record to contain the new billing record structure.<br>
<br>
In general, the responsibility of the billing server is to generate billing messages that relate to the activities on the Domino server for the types of each configured billing class. The Extension Manager support on the Domino server provides a programmatic hook into many of the internal operations on the Domino server and is an ideal framework for extending the billing activities with a custom billing server.<br>
<br>
The remainder of this section contains code segments from the billing sample BILLMNGR to help illustrate how to write a custom billing server. Default Domino server database billing tracks the amount of elapsed time a database is open per session. The BILLMNGR sample extends the database billing class by tracking creation and deletion of databases, providing the capability to bill consumers for additional database-related activities.<br>
<br>
The BILLMNGR sample is a program library (DLL) that registers a Domino Server Extension Manager (EM) handler routine for tracing the NSFDbCreate and NSFDbDelete API functions. The Domino server calls these functions whenever a database is created or deleted.  Each time the API is called, an associated Extension Manager event is generated.  The EM handler routine creates new billing messages for these events and writes them to the billing message queue using the API function BillingWrite.  For more information on programming to the Extension Manager, refer to the &quot;Extension Manager&quot; chapter of this <i>User Guide</i>.  For API billing function information, refer to the <i>Reference.</i><br>
<br>
<br>

<table width="100%" border="1">
<tr valign="top"><td width="100%"><b>Custom Billing Message Definitions Used by Sample Program BILLMNGR (bill_ext.h)</b></td></tr>
</table>
<tt><font size="2">/* New Billing Structure Type */</font></tt><br>
<tt><font size="2">#define BILL_NOTECREATEREC &nbsp; 32001 &nbsp;/* Billmngr extension: Note create type */</font></tt><br>
<br>
<tt><font size="2">/* New Billing Actions */</font></tt><br>
<tt><font size="2">#define BILL_NOTECREATE &nbsp; &nbsp; &nbsp; 1001 &nbsp;/* Billmngr extension: Note create action */<br>
</font></tt><br>
<tt><font size="2">/* New Billing Record Structure */.</font></tt><br>
<tt><font size="2">typedef struct<br>
{<br>
 &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp;Username[MAXUSERNAME+1]; &nbsp; /* Username */<br>
 &nbsp; NOTEID &nbsp; &nbsp; &nbsp;dbNoteID; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Created note id */ <br>
 &nbsp; TIMEDATE &nbsp; &nbsp;ReplicaID; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Database replica id */<br>
} NOTECREATEREC;</font></tt><br>
<br>
<tt><font size="2">/* Modified Billing Record */</font></tt><br>
<tt><font size="2">typedef union<br>
{<br>
 &nbsp; SESSIONREC &nbsp; &nbsp;sess;<br>
 &nbsp; REPLREC &nbsp; &nbsp; &nbsp; repl;<br>
 &nbsp; DOCUMENT &nbsp; &nbsp; &nbsp;doc;<br>
 &nbsp; MAILREC &nbsp; &nbsp; &nbsp; mail;<br>
 &nbsp; DBREC &nbsp; &nbsp; &nbsp; &nbsp; db;</font></tt><br>
<tt><font size="2">&nbsp; &nbsp;AGENTREC &nbsp; &nbsp; &nbsp;agent;</font></tt><br>
<tt><font size="2">&nbsp; &nbsp;HTTPREQREC &nbsp; &nbsp;HttpRequest;</font></tt><br>
<tt><font size="2">&nbsp; &nbsp;NOTECREATEREC notecreate; &nbsp; /* Extended note create billing record */<br>
} BILLREC;</font></tt><br>
<br>
<br>
The above code shows the data type and symbol definition extensions for the note creation billing activity that the BILLMNGR sample billing server uses. For this sample, the API billing header file billing.h has been copied to the sample directory, renamed bill_ext.h, and modified with the above definition extensions. This file replaces the billing.h include file packaged with the HCL C API for Domino and Notes toolkit. It is included by the BILLMNGR sample source file.<br>
<br>
<br>

<table width="100%" border="1">
<tr valign="top"><td width="100%"><b>Billing Extension Manager Handler Routine for Sample Program BILLMNGR (billmngr.c)</b></td></tr>
</table>
<tt><font size="2">STATUS LNCALLBACK BillHandler ( EMRECORD FAR * theData )<br>
{ <br>
 &nbsp; <br>
 &nbsp; STATUS &nbsp; &nbsp; error = NOERROR;<br>
 &nbsp; BILLMSG &nbsp; &nbsp;BillMsg;<br>
 &nbsp; VARARG_PTR argPtr;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;NOTEHANDLE hNote; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* NSFNoteUpdateExtended argument */<br>
 &nbsp; HANDLE &nbsp; &nbsp; hDb; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Associated DB handle */<br>
 &nbsp; char &nbsp; &nbsp; &nbsp; Username[MAXUSERNAME+1]; &nbsp; &nbsp; &nbsp;/* Note create user */ &nbsp;<br>
 &nbsp; NOTEID &nbsp; &nbsp; NoteId; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* NOTEID of note */<br>
 &nbsp; DBID &nbsp; &nbsp; &nbsp; DbId; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* DBID of note */<br>
 &nbsp; char &nbsp; &nbsp; &nbsp; Servername[MAXUSERNAME+1]; &nbsp; &nbsp;/* Server name */ &nbsp;</font></tt><br>
<tt><font size="2">&nbsp; &nbsp;DWORD &nbsp; &nbsp; &nbsp;BillClass; <br>
</font></tt><br>
<tt><font size="2">/* Check to see if Database billing class is enabled. If not, return without<br>
 &nbsp; sending billing record */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;if (error = BillingGetClass( &amp;BillClass ))</font></tt><br>
<br>
<tt><font size="2">/* Only bill if the API was successful. If not, return without sending <br>
 &nbsp; billing record. */<br>
 &nbsp; &nbsp; <br>
 &nbsp; &nbsp; &nbsp;goto Done;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;if ((BOOL)(BillClass &amp; BILL_CLASS_DATABASE))<br>
 &nbsp; {</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; if ( theData-&gt;Status != NOERROR )<br>
 &nbsp; &nbsp; &nbsp; &nbsp; goto Done;<br>
 &nbsp; &nbsp; &nbsp;</font></tt><br>
<tt><font size="2">/* otherwise handle Note Create billing by interpreting NSFNoteUpdateExtended calls */<br>
 &nbsp; &nbsp; &nbsp;<br>
 &nbsp; &nbsp; &nbsp;argPtr = theData-&gt;Ap;</font></tt><br>
<br>
<tt><font size="2">/* Before the API: &nbsp;check to see if the Note ID is equal to zero. &nbsp; If it is <br>
 &nbsp; then this means a new note is being created and we should track the output. */<br>
 &nbsp; <br>
 &nbsp; &nbsp; &nbsp;if ( theData-&gt;NotificationType == EM_BEFORE )<br>
 &nbsp; &nbsp; &nbsp;{<br>
 &nbsp; &nbsp; &nbsp; &nbsp; hNote = VARARG_GET (argPtr, HANDLE); &nbsp; /* save note handle */<br>
 &nbsp; &nbsp; &nbsp; &nbsp; (void) VARARG_GET (argPtr, DWORD); &nbsp; &nbsp; &nbsp;/* skip update flags */<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
 &nbsp; /* get NOTEID of input note handle */<br>
 &nbsp; &nbsp; &nbsp; &nbsp; NSFNoteGetInfo(hNote, _NOTE_ID, &amp;NoteId);</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;/* if NOTEID = 0, then set for billing */<br>
 &nbsp; &nbsp; &nbsp; &nbsp; if (NoteId == 0)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gCreatedNote = TRUE;				<br>
 &nbsp; &nbsp; &nbsp; &nbsp; else<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gCreatedNote = FALSE;				<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; return ( ERR_EM_CONTINUE ); /* continue;, billing occurs after call */<br>
 &nbsp; &nbsp; &nbsp;}</font></tt><br>
<br>
<tt><font size="2">/* If after the call and a new note was created, fill in the UserName, Note ID, <br>
 &nbsp; and Replica ID of the created note in the billing record. */</font></tt><br>
<br>
<tt><font size="2">/* NOTE: Since a global is used to determine if a new note was created, this <br>
 &nbsp; &nbsp; &nbsp; &nbsp; logic assumes that the EM_AFTER handling occurs before a different <br>
 &nbsp; &nbsp; &nbsp; &nbsp; NSFNoteUpdateExtended EM_BEFORE thread is handled by Domino. &nbsp;For heavily</font></tt><br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;loaded systems, it may be necessary to serialize these requests. */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; if (gCreatedNote == TRUE)<br>
 &nbsp; &nbsp; &nbsp;{<br>
 &nbsp; &nbsp; &nbsp; &nbsp; memset( &amp;(BillMsg.rec.notecreate), (char)0, sizeof( BillMsg.rec.notecreate ) );<br>
 &nbsp; &nbsp; &nbsp; &nbsp; hNote = VARARG_GET (argPtr, HANDLE); &nbsp; /* save note handle */<br>
 &nbsp; &nbsp; &nbsp; &nbsp; (void) VARARG_GET (argPtr, DWORD); &nbsp; &nbsp; &nbsp;/* skip update flags */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;/* get NOTEID of note handle */<br>
 &nbsp; &nbsp; &nbsp; &nbsp; NSFNoteGetInfo(hNote, _NOTE_ID, &amp;NoteId);</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;/* get the DBHANDLE for note handle */<br>
 &nbsp; &nbsp; &nbsp; &nbsp; NSFNoteGetInfo(hNote, _NOTE_DB, &amp;hDb);</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;/* get DBID associated with the DBHANDLE */<br>
 &nbsp; &nbsp; &nbsp; &nbsp; NSFDbIDGet(hDb, &amp;DbId);</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;/* get USERNAME associated with the DBHANDLE */<br>
 &nbsp; &nbsp; &nbsp; &nbsp; (void) NSFDbUserNameGet(hDb, Username, MAXUSERNAME);</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;/* if user is the server, then do not bill */<br>
 &nbsp; &nbsp; &nbsp; &nbsp; (void) SECKFMGetUserName(Servername);<br>
 &nbsp; &nbsp; &nbsp; &nbsp; if (!strcmp(Username, Servername))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;goto Done; 	 &nbsp; &nbsp; </font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;/* else, set billing message fields with appropriate info*/<br>
 &nbsp; &nbsp; &nbsp; &nbsp; strcpy(BillMsg.rec.notecreate.Username, Username);<br>
 &nbsp; &nbsp; &nbsp; &nbsp; BillMsg.rec.notecreate.dbNoteID = NoteId; &nbsp;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; BillMsg.rec.notecreate.ReplicaID = DbId; &nbsp;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;/* and write the billing record */<br>
 &nbsp; &nbsp; &nbsp; &nbsp; error = BillingWrite( (DWORD)BILL_CLASS_DATABASE, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (WORD)BILL_NOTECREATEREC, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof( BillMsg ),<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;BillMsg,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BILL_QUEUE_NAME );<br>
 &nbsp; &nbsp; &nbsp;}<br>
 &nbsp; }</font></tt><br>
<br>
<tt><font size="2">/* Whether or not the Billing the record was written, return the original<br>
 &nbsp; NSFNoteUpdateExtended (EM_AFTER) status back to Domino */ &nbsp; &nbsp;</font></tt><br>
<br>
<tt><font size="2">Done:<br>
 &nbsp; if (theData &amp;&amp; theData-&gt;NotificationType == EM_BEFORE)<br>
 &nbsp; &nbsp; &nbsp;return( ERR_EM_CONTINUE );<br>
 &nbsp; else</font></tt><br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; return( theData-&gt;Status );</font></tt><br>
<br>
<tt><font size="2">}</font></tt><br>
<br>
<br>
The above routine is the callback function (EM handler routine) that is registered with the Extension Manager to handle the EM_NFSNOTEUPDATE event generated by NFSNoteUpdate API. This routine performs the following billing server-related tasks:<br>

<ul type="disc">
<li>Call the API function BillingGetClass to determine if the database billing class is configured on the server; only continue if active.
<li>Check the status of the function being tracked; only continue if successful.
<li>During EM_BEFORE handling, check that the input Note handle argument to NSFNoteUpdate is associated with a newly-created note.
<li>During EM_AFTER handling,  fill in the billing record structure for the customized BILL_NOTECREATEREC structure type for the note create (as long as the note is not being created by the server).
<li>Call the API function BillingWrite to write the billing message to the message queue.<br>
</ul>
NOTE: The billing server is responsible for calling the Extension Manager API functions for registering and deregistering the EM handler routines. The BILLMNGR sample calls these functions in other routines that are not displayed above. <br>
<br>
Also note that the BILLMNGR sample writes the billing messages to the default billing message queue, BILL_QUEUE_NAME. You do not have to use this message queue; in fact, it may be desirable to separate the custom billing messages. <br>
<br>
<br>
<b><font size="5" color="#000080">Reading a Billing Message (Billing Add-In Sample)</font></b><br>
<br>
As billing messages are being queued, a program needs to be running to extract, interpret, and store the information as appropriate for subsequent reporting. Since you can only call the Domino message queue API functions from a local server task, you must write a server add-in program, referred to here as a &quot;billing add-in.&quot;<br>
<br>
The general responsibility of the billing add-in is to get an open message queue handle to the billing message queue (or queues, if you are using more than one), retrieve and store any billing messages, and report on those relevant to the important billing classes and record types.  To store the messages from the queue, the billing add-in uses the same billing data structures and symbols that the billing server uses to write the billing messages. Once it reads the information, the billing add-in should place this information in an appropriate billing system form, such as a Domino database or a proprietary accounting file format.<br>
<br>
The remainder of this section contains code segments from the billing sample NBILLSES to illustrate how to program a billing add-in. NBILLSES is loaded as a Domino server task. It periodically reads billing messages off the message queue, filters out all session and database billing class records, and appends the information to a predesigned database. The sample reads both standard and custom (extended) billing messages generated on the Domino server. To use the custom billing record structures and symbols, NBILLSES includes the header file bill_ext.h.<br>
<br>
For details on programming a server add-in, Refer to the Server Add-In Task chapter of this <i>User Guide</i>. For information about the API message queue  refer to the Message Queues chapter of this guide.<br>
<br>
<br>

<table width="100%" border="1">
<tr valign="top"><td width="100%"><b>Billing AddInMain Routine for Sample Program NBILLSES (billses.c)</b></td></tr>
</table>
<tt><font size="2">STATUS LNPUBLIC AddInMain (HMODULE hResourceModule, int argc, char *argv[])<br>
{<br>
 &nbsp; STATUS &nbsp; error;<br>
 &nbsp; MQHANDLE bMsgQueue=NULL;<br>
 &nbsp; DWORD &nbsp; &nbsp;Wakeup=0, Runtime=0, BillingClass=0;<br>
 &nbsp; HANDLE &nbsp; hDB;<br>
 &nbsp; char &nbsp; &nbsp; *Message=0;<br>
 &nbsp; WORD &nbsp; &nbsp; msgsize=sizeof(BILLMSG);<br>
 &nbsp; BOOL &nbsp; &nbsp; fBillingDBOpen=FALSE;</font></tt><br>
<br>
<tt><font size="2">/* Default is to wake up every minute and run for 10 seconds. */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;if (! (Wakeup = OSGetEnvironmentLong(&quot;BillingAddinWakeup&quot;)) )<br>
	 &nbsp; Wakeup = 60;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;if (! (Runtime = OSGetEnvironmentLong(&quot;BillingAddinRuntime&quot;)) )<br>
	 &nbsp; Runtime = 10;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;if (Runtime &gt; Wakeup)<br>
 &nbsp; {<br>
 &nbsp; &nbsp; &nbsp;AddInLogMessageText(MSG_ADDIN_TERMINATING, NULL);<br>
 &nbsp; &nbsp; &nbsp;return (NOERROR);<br>
 &nbsp; }</font></tt><br>
<br>
<tt><font size="2">/* Log that the billing task has started. */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;AddInLogMessageText(MSG_ADDIN_STARTED, NULL);</font></tt><br>
<br>
<tt><font size="2">/* Set the task into &quot;Initializing&quot; state */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;AddInSetStatusText(MSG_ADDIN_INITIALIZING, 0L);</font></tt><br>
<br>
<tt><font size="2">/* Initialize the Message Queue */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;if (error = MQCreate(BILL_QUEUE_NAME, MAXWORD, 0))<br>
 &nbsp; {<br>
 &nbsp; &nbsp; &nbsp;if (error != ERR_DUPLICATE_MQ)<br>
 &nbsp; &nbsp; &nbsp;{<br>
 &nbsp; &nbsp; &nbsp; &nbsp; AddInLogErrorText(MSG_ADDIN_ERROR, error, &quot;MQCreate&quot;);<br>
 &nbsp; &nbsp; &nbsp; &nbsp; return (NOERROR);<br>
 &nbsp; &nbsp; &nbsp;}<br>
 &nbsp; }<br>
 <br>
 &nbsp; if (error = MQOpen (BILL_QUEUE_NAME, 0, &amp;bMsgQueue))<br>
 &nbsp; {<br>
 &nbsp; &nbsp; &nbsp;AddInLogErrorText(MSG_ADDIN_ERROR, error,&quot;MQOpen&quot;);<br>
 &nbsp; &nbsp; &nbsp;return (NOERROR);<br>
 &nbsp; }</font></tt><br>
<br>
<tt><font size="2">/* Allocate enough memory to hold the session struct returned in message */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;if( (Message = malloc( msgsize)) == NULL)<br>
 &nbsp; {<br>
 &nbsp; &nbsp; &nbsp;AddInLogErrorText(MSG_ADDIN_ERROR_NOMEMORY, 0L,&quot;Malloc()&quot;);<br>
 &nbsp; &nbsp; &nbsp;return(NOERROR);<br>
 &nbsp; }</font></tt><br>
<br>
<tt><font size="2">/* Create/Open the billing sample database */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;if (error = BillingDBOpen (&amp;hDB))<br>
 &nbsp; {<br>
 &nbsp; &nbsp; &nbsp;AddInLogErrorText (MSG_ADDIN_ERROR_DBOPEN, error, NULL); <br>
 &nbsp; &nbsp; &nbsp;goto done;<br>
 &nbsp; }<br>
 &nbsp; else<br>
 &nbsp; &nbsp; &nbsp;fBillingDBOpen = TRUE;</font></tt><br>
<br>
<tt><font size="2">/* Run until Message Queue is not in QUIT state */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;while (!MQIsQuitPending(bMsgQueue))<br>
 &nbsp; {<br>
 &nbsp; &nbsp; &nbsp;WORD len;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; AddInSetStatusText(MSG_ADDIN_IDLE, 0L);<br>
		<br>
 &nbsp; /* Yield processor to other tasks and reset schedules. <br>
 &nbsp; &nbsp; &nbsp;Quit if server terminates. */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; if (AddInIdle())<br>
 &nbsp; &nbsp; &nbsp;{<br>
		<br>
 &nbsp; &nbsp; &nbsp;/* Empty the queue. */<br>
	 &nbsp; <br>
 &nbsp; &nbsp; &nbsp; &nbsp; AddInSetStatusText(MSG_ADDIN_PROCESSBILLING, 0L);<br>
 &nbsp; &nbsp; &nbsp; &nbsp; while (TRUE)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; {<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;error=MQGet(bMsgQueue, Message, msgsize, 0, 0, &amp;len);<br>
 &nbsp; &nbsp;<br>
	 /* Queue is empty. &nbsp;Stop processing. */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (error) <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (error != ERR_MQ_EMPTY)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AddInLogErrorText(MSG_ADDIN_ERROR, error,&quot;MQGet Quit&quot;);<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>
		<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if ((len &lt;= 0) || (error))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br>
 &nbsp; &nbsp;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (error = BillingMessageToDB ((BILLMSG*) Message, hDB, len))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AddInLogErrorText (MSG_ADDIN_ERROR_WRITEDB, error, NULL);<br>
 &nbsp; &nbsp; &nbsp; &nbsp; }<br>
		 <br>
 &nbsp; &nbsp; &nbsp; &nbsp; goto done;<br>
 &nbsp; &nbsp; &nbsp;}<br>
	<br>
 &nbsp; /* Read the Billing message queue every X (default: 60) seconds. */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; if (AddInSecondsHaveElapsed(Wakeup))<br>
 &nbsp; &nbsp; &nbsp;{</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TIMEDATE Now, DueTime;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AddInSetStatusText(MSG_ADDIN_PROCESSBILLING, 0L);</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; /* Get a billing message */<br>
 &nbsp; &nbsp; &nbsp;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; error=MQGet(bMsgQueue, Message, msgsize, 0, 0, &amp;len);</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (error) <br>
 &nbsp; &nbsp; &nbsp; &nbsp; {<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (error != ERR_MQ_EMPTY)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AddInLogErrorText(MSG_ADDIN_ERROR, error,&quot;MQGet&quot;);<br>
 &nbsp; &nbsp; &nbsp; &nbsp; } </font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp;/* Got a message, bill it (and the rest) to the database. */<br>
	 <br>
 &nbsp; &nbsp; &nbsp; &nbsp; if ((len &gt; 0) &amp;&amp; (error==NOERROR) )<br>
 &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OSCurrentTIMEDATE(&amp;DueTime);<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TimeDateIncrement(&amp;DueTime, Runtime*100);</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (TRUE)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (error = BillingMessageToDB ((BILLMSG*) Message, hDB, len))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AddInLogErrorText (MSG_ADDIN_ERROR_WRITEDB, error, NULL);</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OSCurrentTIMEDATE(&amp;Now);<br>
			<br>
 &nbsp; &nbsp; &nbsp; &nbsp; /* Time is up. &nbsp;Stop processsing. */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (TimeDateCompare(&amp;Now, &amp;DueTime) &gt;= 0)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OSCurrentTIMEDATE(&amp;DueTime);<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TimeDateIncrement(&amp;DueTime, Runtime*100);<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;error=MQGet(bMsgQueue, Message, msgsize, 0, 0, &amp;len);<br>
	 &nbsp; &nbsp;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (error)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (error != ERR_MQ_EMPTY)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AddInLogErrorText(MSG_ADDIN_ERROR, error,&quot;MQGet&quot;);<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Queue is empty. &nbsp;Stop processing. */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if ((len == 0) || (error))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;<br>
 &nbsp; &nbsp; &nbsp;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp;/* end while true- mqget */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} /* end len &gt; 0 */<br>
		<br>
 &nbsp; &nbsp; &nbsp;} &nbsp;/* end minutes elapsed*/<br>
		<br>
 &nbsp; } /* end while !quit */</font></tt><br>
<br>
<br>
<tt><font size="2">done:<br>
 &nbsp; if (Message)<br>
 &nbsp; &nbsp; &nbsp;free (Message);</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;AddInLogMessageText(MSG_ADDIN_TERMINATING, NULL);</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;MQClose(bMsgQueue, 0);</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;if (fBillingDBOpen)<br>
 &nbsp; {<br>
 &nbsp; &nbsp; &nbsp;if (error = NSFDbClose (hDB))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; AddInLogErrorText (MSG_ADDIN_ERROR, error, &quot;closing sessbill.nsf&quot;);<br>
 &nbsp; }</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;return(NOERROR);<br>
}</font></tt><br>
<br>
The above routine is the main add-in function for the NBILLSES sample. It illustrates a well-behaved server add-in task that performs the following billing add-in tasks:<br>

<ul type="disc">
<li>Create and open the billing message queue.
<li>Periodically retrieve billing messages from the queue.
<li>Store the billing message in an allocated BILLMSG buffer.
<li>Call a routine to store the message in a Domino database.
<li>Close the message queue when told to exit.  </ul>

<p>NOTE: This routine references add-in status message literals defined in the header file billses.h, which is included by the NBILLSES sample. The &quot;Wakeup&quot; and &quot;Runtime&quot; variables are read from user-configured settings in the server notes.ini file. They specify how frequently the NBILLSES sample reads from the message queue and the length of processing time. For more information, see the<i> Domino Administration Help </i>documentation<i>.</i><br>
<br>
<br>

<table width="100%" border="1">
<tr valign="top"><td width="100%"><b>Routine to Store Billing Messages to a Database for Sample Program NBILLSES (billses.c)</b></td></tr>
</table>
<tt><font size="2">STATUS LNPUBLIC BillingMessageToDB (BILLMSG *Message, HANDLE hDb, DWORD len)<br>
{<br>
 &nbsp; HANDLE hNote;<br>
 &nbsp; NUMBER FloatTemp, DWordTemp;<br>
 &nbsp; STATUS error;<br>
 &nbsp; long &nbsp; tmp;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;/* Create a new note to hold the billing record */<br>
 &nbsp; &nbsp;<br>
 &nbsp; if (error = NSFNoteCreate(hDb, &amp;hNote))<br>
 &nbsp; &nbsp; &nbsp;goto Done;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;/* First write the billing record header (shared) info to the note */<br>
 &nbsp; &nbsp;<br>
 &nbsp; /* Header: &nbsp;Add Message class */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;FloatTemp = (NUMBER) Message-&gt;Class;<br>
 &nbsp; if (error = NSFItemAppend(hNote, ITEM_SUMMARY, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BILL_ITEM_HEADER_CLASS, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof(BILL_ITEM_HEADER_CLASS) - 1, 	 &nbsp; &nbsp;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPE_NUMBER, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;	 &nbsp; &nbsp;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;FloatTemp, (DWORD) sizeof(FloatTemp))) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 	 &nbsp; &nbsp;<br>
 &nbsp; &nbsp; &nbsp;goto Done;<br>
	 &nbsp; &nbsp;<br>
 &nbsp; /* Header: &nbsp;Add Message StructType */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;FloatTemp = (NUMBER) Message-&gt;StructType;<br>
 &nbsp; if (error = NSFItemAppend(hNote, ITEM_SUMMARY, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BILL_ITEM_HEADER_STRUCTTYPE, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof(BILL_ITEM_HEADER_STRUCTTYPE) - 1, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPE_NUMBER,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;FloatTemp, (DWORD) sizeof(FloatTemp)))<br>
 &nbsp; &nbsp; &nbsp;goto Done;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;/* Header: &nbsp;Add timestamp */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;if (error = NSFItemAppend(hNote, ITEM_SUMMARY, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BILL_ITEM_HEADER_TIMESTAMP, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof(BILL_ITEM_HEADER_TIMESTAMP) - 1, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPE_TIME, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;Message-&gt;TimeStamp, (DWORD) sizeof(TIMEDATE)))<br>
 &nbsp; &nbsp; &nbsp;goto Done;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;/* Header: &nbsp;Add Servername */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;if (error = NSFItemAppend(hNote, ITEM_SUMMARY, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BILL_ITEM_HEADER_SERVERNAME, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof(BILL_ITEM_HEADER_SERVERNAME) - 1, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPE_TEXT,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message-&gt;ServerName, (DWORD) strlen(Message-&gt;ServerName)))<br>
 &nbsp; &nbsp; &nbsp;goto Done;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;/* Then write the billing message structtype specific info to the note */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;switch (Message-&gt;StructType)<br>
 &nbsp; {</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;/* Standard Session billing */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; case BILL_SESSIONREC:<br>
		 &nbsp;<br>
 &nbsp; &nbsp; &nbsp;/* Set the billing record type to type Session */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (error = NSFItemSetText(hNote, FIELD_FORM, BILLING_SESSION_FORM,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (WORD) strlen(BILLING_SESSION_FORM))) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;goto Done;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; /* Session: &nbsp;Add SessionID*/</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;memmove( &amp;tmp, &amp;Message-&gt;rec.sess.SessionID, sizeof( long));<br>
	<br>
 &nbsp; &nbsp; &nbsp; &nbsp; FloatTemp = (NUMBER) tmp;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; if (error = NSFItemAppend(hNote, ITEM_SUMMARY, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BILL_ITEM_SESSION_SESSIONID, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof(BILL_ITEM_SESSION_SESSIONID) - 1, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPE_NUMBER,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;FloatTemp, (DWORD) sizeof(FloatTemp)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;goto Done;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; /* Session: &nbsp;Add BytesIn */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FloatTemp = (NUMBER) Message-&gt;rec.sess.BytesIn;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; if (error = NSFItemAppend(hNote, ITEM_SUMMARY, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BILL_ITEM_SESSION_BYTESIN, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof(BILL_ITEM_SESSION_BYTESIN) - 1, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPE_NUMBER,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;FloatTemp, (DWORD) sizeof(FloatTemp)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;goto Done;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; /* Session: &nbsp;Add BytesOut */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FloatTemp = (NUMBER) Message-&gt;rec.sess.BytesOut;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; if (error = NSFItemAppend(hNote, ITEM_SUMMARY, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BILL_ITEM_SESSION_BYTESOUT, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof(BILL_ITEM_SESSION_BYTESOUT) - 1, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPE_NUMBER,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;FloatTemp, (DWORD) sizeof(FloatTemp)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;goto Done;<br>
	<br>
 &nbsp; &nbsp; &nbsp;/* Session: &nbsp;Username */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (error = NSFItemAppend(hNote, ITEM_SUMMARY, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BILL_ITEM_SESSION_USERNAME, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof(BILL_ITEM_SESSION_USERNAME) - 1, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPE_TEXT,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message-&gt;rec.sess.Username, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (DWORD) strlen(Message-&gt;rec.sess.Username)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;goto Done;<br>
 &nbsp;<br>
 &nbsp; &nbsp; &nbsp;/* Session: &nbsp;Add Action*/</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FloatTemp = (NUMBER) Message-&gt;rec.sess.Action;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; if (error = NSFItemAppend(hNote, ITEM_SUMMARY, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BILL_ITEM_SESSION_ACTION, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof(BILL_ITEM_SESSION_ACTION) - 1, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPE_NUMBER,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;FloatTemp, (DWORD) sizeof(FloatTemp)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;goto Done;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; /* Session: &nbsp;Network Address of client */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (error = NSFItemAppend(hNote, ITEM_SUMMARY, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BILL_ITEM_SESSION_NETADR,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof(BILL_ITEM_SESSION_NETADR) - 1, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPE_TEXT,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message-&gt;rec.sess.NetAdr, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (DWORD) strlen(Message-&gt;rec.sess.NetAdr)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;goto Done;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;</font></tt><br>
<br>
<br>
<tt><font size="2">&nbsp; &nbsp;/* Standard Database billing */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; case BILL_DBREC:</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; /* Set the billing record type to type DB */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (error = NSFItemSetText(hNote, FIELD_FORM, BILLING_DB_FORM, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (WORD) strlen(BILLING_DB_FORM))) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;goto Done;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; /* Database: &nbsp;Add SessionID*/</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;memmove (&amp;tmp, &amp;Message-&gt;rec.db.SessionID, sizeof (long));<br>
 &nbsp; <br>
 &nbsp; &nbsp; &nbsp; &nbsp; FloatTemp = (NUMBER) tmp;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; if (error = NSFItemAppend(hNote, ITEM_SUMMARY, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BILL_ITEM_DB_SESSIONID, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof(BILL_ITEM_DB_SESSIONID) - 1, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPE_NUMBER,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;FloatTemp, (DWORD) sizeof(FloatTemp)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;goto Done;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; /* Database: &nbsp;Add ReplicaID */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (error = NSFItemAppend(hNote, ITEM_SUMMARY, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BILL_ITEM_DB_REPLICAID, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof(BILL_ITEM_DB_REPLICAID) - 1, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPE_TIME,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;Message-&gt;rec.db.ReplicaID, (DWORD) sizeof(TIMEDATE)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;goto Done;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; /* Database: &nbsp;Username */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (error = NSFItemAppend(hNote, ITEM_SUMMARY, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BILL_ITEM_DB_USERNAME, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof(BILL_ITEM_DB_USERNAME) - 1, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPE_TEXT,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message-&gt;rec.db.Username, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (DWORD) strlen(Message-&gt;rec.sess.Username)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;goto Done;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; /* Database: &nbsp;Add DBOpenTime */<br>
 &nbsp; &nbsp; &nbsp;/* Convert from Centiseconds to Seconds, and Round up */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tmp = (Message-&gt;rec.db.DBOpenTime + 50) / 100;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; FloatTemp = (NUMBER) tmp;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (error = NSFItemAppend(hNote, ITEM_SUMMARY, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BILL_ITEM_DB_OPENTIME, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof(BILL_ITEM_DB_OPENTIME) - 1, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPE_NUMBER,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;FloatTemp, (DWORD) sizeof(FloatTemp)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;goto Done;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; /* Database: &nbsp;Add Action*/<br>
 &nbsp; &nbsp; &nbsp; &nbsp; FloatTemp = (NUMBER) Message-&gt;rec.db.Action;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; if (error = NSFItemAppend(hNote, ITEM_SUMMARY, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BILL_ITEM_DB_ACTION, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof(BILL_ITEM_DB_ACTION) - 1, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPE_NUMBER,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;FloatTemp, (DWORD) sizeof(FloatTemp)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;goto Done;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;<br>
 &nbsp; &nbsp; &nbsp;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;/* Note Create (extended) billing */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; case BILL_NOTECREATEREC:</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; /* Set the billing record type to type &nbsp;NOTECREATE */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (error = NSFItemSetText(hNote, FIELD_FORM, BILLING_NOTECREATE_FORM, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (WORD) strlen(BILLING_NOTECREATE_FORM))) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto Done;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; /* Note Create: &nbsp;Add NoteUser*/</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (error = NSFItemAppend(hNote, ITEM_SUMMARY, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BILL_ITEM_NOTECREATE_USER, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof(BILL_ITEM_NOTECREATE_USER) - 1, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPE_TEXT,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message-&gt;rec.notecreate.Username,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (DWORD) strlen(Message-&gt;rec.notecreate.Username)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;goto Done;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; /* Note Create: &nbsp;Add NOTEID */<br>
 &nbsp; &nbsp; &nbsp; &nbsp; DWordTemp = (NUMBER) Message-&gt;rec.notecreate.dbNoteID;<br>
 &nbsp; &nbsp; &nbsp; &nbsp; if (error = NSFItemAppend(hNote, ITEM_SUMMARY, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BILL_ITEM_NOTECREATE_NOTEID, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof(BILL_ITEM_NOTECREATE_NOTEID) - 1, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPE_NUMBER,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;DWordTemp, (DWORD) sizeof(DWordTemp)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;goto Done;</font></tt><br>
<br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; /* Note Create: &nbsp;Add ReplicaID */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (error = NSFItemAppend(hNote, ITEM_SUMMARY, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BILL_ITEM_NOTECREATE_REPLICAID,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof(BILL_ITEM_NOTECREATE_REPLICAID) - 1, <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPE_TIME,<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;Message-&gt;rec.notecreate.ReplicaID, (DWORD) sizeof(TIMEDATE)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;goto Done;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;<br>
	 </font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; default:</font></tt><br>
<br>
<tt><font size="2">	 /* No processing for &quot;other&quot; billing record messages */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;goto Done; <br>
 &nbsp; &nbsp; &nbsp; &nbsp; break;</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;} &nbsp;/* end switch */</font></tt><br>
<br>
<br>
<tt><font size="2">/* &nbsp;Update the note */</font></tt><br>
<br>
<tt><font size="2">&nbsp; &nbsp;error = NSFNoteUpdate(hNote, UPDATE_FORCE|UPDATE_NOREVISION); &nbsp; /* Suppress ERR_CONFLICT */</font></tt><br>
<br>
<tt><font size="2">/* and close the note when done */</font></tt><br>
<br>
<tt><font size="2">Done:<br>
 &nbsp; if (hNote != NULLHANDLE)<br>
 &nbsp; &nbsp; &nbsp;NSFNoteClose(hNote);<br>
 &nbsp; return (error);</font></tt><br>
<br>
<tt><font size="2">}</font></tt><br>
<br>
<br>
The AddInMain function of the NBILLSES sample calls the above routine to store a billing message buffer in a database. This routine illustrates how to selectively produce billing information by filtering the message for specific billing record structure types. In this case, only session, database, and the custom (BILLMNGR) billing information is written to the database.<br>
<br>
NOTE: This routine references database form item literals defined in the header file billses.h, which is included by the NBILLSES sample. The database template sessbill.ntf, supplied with the NBILLSES sample, contains the necessary forms and views to report on the billing information.
---
