##### Chapter 9-14
##### Single Sign-On with Domino and WebSphere

<b><font size="5" color="#000080">Single Sign-On with Domino and WebSphere</font></b><br>
<br>
Domino provides a cryptographic token based mechanism to provide Single Sign-On support between protocols such as HTTP and DIIOP, and also with the IBM WebSphere application server. The servers that participate in Single Sign-On use an encrypted &quot;Web SSO Configuration&quot; to share secret data in the Domino Directory used for generating and validating Single Sign-On tokens. This secret information is used by the server to verify that the token presented by a user was generated by a server that shares the same secret.<br>
<br>
WebSphere uses a format called Lightweight Third Party Authentication (LTPA), which was implemented in Domino in Release 5.0.5. Enabling Domino to interoperate with WebSphere for Single Sign-On.  This requires generating the secret information within the WebSphere administration environment and then importing it into the Web SSO Configuration. Consult WebSphere product documentation for more information on configuring LTPA in WebSphere.<br>
<br>
When interoperability with WebSphere is not required, Domino uses its own format for the Single Sign-On token that is slightly different from the one implemented by WebSphere. The servers participating in Domino Single Sign-On share a 20 byte secret that is used to generate and validate a SHA-1 hash that proves the integrity of the token. Details of the Domino Single Sign-On token format are covered below.<br>
<br>
See the Domino Administrator's Guide for more details on configuring Single Sign-On.<br>
<br>
<br>
<b><font size="5" color="#000080">Using the SECToken APIs</font></b><br>
<br>
The Domino C API provides several functions that allow Domino C API applications to use Single Sign-On as an authentication mechanism. Domino itself uses these APIs to generate and validate Single Sign-On tokens for the HTTP and DIIOP server tasks. These tasks are configured to use a specific Web SSO Configuration, which can also be enabled to be part of an Organization (when using Domino 6 &quot;Site Documents&quot;). The SECToken APIs require the caller to specify a specific Configuration (and possibly Organization) from which the shared secrets used in generating and validating tokens are retrieved.<br>
<br>
Server addin tasks that wish to implement their own authentication schemes can use these APIs to provide Single Sign-On using the token as an authentication credential, and also to interoperate with Domino protocols that support Single Sign-On.<br>
<br>
For example, after an HTTP user is authenticated via name and password, SECTokenGenerate is called and returns the information necessary to store the Single Sign-On token in a browser cookie. The mhData member of the SSO_TOKEN structure is a MEMHANDLE to the BASE64 encoded Single Sign-On token. SECTokenGenerate also allows the caller to pass an optional expiration time to override the one specified in the Web SSO Configuration.
<ul>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr valign="top"><td width="100%" bgcolor="#EFEFEF">
<ul><font color="#008000" face="Courier New">/* Generate the token for the specified username.</font><br>
<font color="#008000" face="Courier New"> */</font><br>
<font face="Courier New">error = SECTokenGenerate(NULL, &quot;ORGNAME&quot;, &quot;CONFIGNAME&quot;,</font><br>
<font face="Courier New">				    szAuthName, NULL, NULL,</font><br>
<font face="Courier New">				    &amp;mhToken, 0, NULL);</font><br>
<font face="Courier New">if (!error)</font>
<ul><font face="Courier New">{</font><br>
<font color="#008000" face="Courier New">/* Lock the token structure and its member data.</font><br>
<font color="#008000" face="Courier New"> */</font><br>
<font face="Courier New">pToken      = (SSO_TOKEN*)OSMemoryLock(mhToken);</font><br>
<font face="Courier New">pName       = (char*)OSMemoryLock(pToken-&gt;mhName);</font><br>
<font face="Courier New">pDomainList = (char*)OSMemoryLock(pToken-&gt;mhDomainList);</font><br>
<font face="Courier New">pData       = (char*)OSMemoryLock(pToken-&gt;mhData);</font><br>
<br>
<font color="#008000" face="Courier New">/* return the data to the client in an appropriate manner</font><br>
<font color="#008000" face="Courier New"> * (IE: browser cookie for HTTP, session object for DIIOP)</font><br>
<font color="#008000" face="Courier New"> */</font><br>
<font face="Courier New">...</font></ul>

<ul><font color="#008000" face="Courier New">/* Free the token memory. </font><br>
<font color="#008000" face="Courier New"> */</font><br>
<font face="Courier New">SECTokenFree(&amp;mhToken);</font><br>
<font face="Courier New">}</font></ul>
</ul>
</td></tr>
</table>
</ul>
<br>
See the C API Reference for more details on function parameters and returns.<br>
<br>
When a token is present as a credential in an HTTP request header, SECTokenValidate is called to validate that the token was generated by a server sharing the same Web SSO Configuration and associated secret data. Encoded in the token is an authenticated name, and also the creation time and expiration time for the token. Note that the creation time is not encoded in the WebSphere format, and thus is not returned when validating a WebSphere LTPA token.<br>
<br>
Any error returned from SECTokenValidate should be considered an authentication failure, and the parameters returned (Username and TimeDates) are only valid when there is no error (NOERROR) or when the token is expired (ERR_LTPA_TOKEN_EXPIRED). The parameter retUsername must be a buffer of size MAXUSERNAME.<br>
<br>

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr valign="top"><td width="100%" bgcolor="#EFEFEF">
<ul><font color="#008000" face="Courier New">/* Validate the token data presented by the client.</font><br>
<font color="#008000" face="Courier New"> */</font><br>
<tt>error = SECTokenValidate(NULL, </tt><font face="Courier New">&quot;ORGNAME&quot;, &quot;CONFIGNAME&quot;,</font><br>
<tt>				 &nbsp; &nbsp;szTokenData, retAuthName,</tt><br>
<tt>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;CreationTIMEDATE,</tt><br>
<tt>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;ExpirationTIMEDATE,</tt><br>
<tt>				 &nbsp; &nbsp;0, NULL);</tt><br>
<br>
<font face="Courier New">if (ERR_LTPA_TOKEN_EXPIRED == error)</font><br>
<font face="Courier New">   {</font><br>
<font face="Courier New">   </font><font color="#008000" face="Courier New">/* Token is expired, handle appropriately.</font><br>
<font color="#008000" face="Courier New">    * (IE: redirect to login page for HTTP, displaying expiration)</font><br>
<font color="#008000" face="Courier New">    */</font><br>
<font face="Courier New">   ...</font><br>
<font face="Courier New">   {</font><br>
<font face="Courier New">else if (ERR_LTPA_TOKEN_INVALID == error)</font><br>
<font face="Courier New">   {</font><br>
<font face="Courier New">  </font><font color="#008000" face="Courier New"> /* Token is cryptographically invalid, handle appropriately.</font><br>
<font color="#008000" face="Courier New">    * (IE: redirect to login page for HTTP)</font><br>
<font color="#008000" face="Courier New">    */</font><br>
<font face="Courier New">   ...</font><br>
<font face="Courier New">   }</font><br>
<font face="Courier New">else if (error)</font><br>
<font face="Courier New">   {</font><br>
<font face="Courier New">   </font><font color="#008000" face="Courier New">/* Some other lower level API error has occurred, handle appropriately.</font><br>
<font color="#008000" face="Courier New">    * (IE: server error 500 for HTTP)</font><br>
<font color="#008000" face="Courier New">    */</font><br>
<font color="#008000" face="Courier New">   </font><font face="Courier New">...</font><br>
<font face="Courier New">   }</font><br>
<br>
<font color="#008000" face="Courier New">/* No error occurred, set the authenticated name and proceed</font><br>
<font color="#008000" face="Courier New"> * with authorization, etc.</font><br>
<font color="#008000" face="Courier New"> */</font><br>
<font face="Courier New">...</font></ul>
</td></tr>
</table>
<br>
See the C API Reference for more details on function parameters and returns.<br>
<br>
<br>
<b><font size="5" color="#000080">Implementing the Domino Single Sign-On token format</font></b><br>
<br>
Applications that wish to participate in Single Sign-On with Domino's format, but do not have access to the Domino C API should be able to implement the format themselves, the only requirements are access to an implementation of BASE-64 encoding/decoding and an implementation of a SHA-1 hashing algorithm. This format of the Single Sign-On token is used by Domino only and does not interoperate with WebSphere's LTPA format for Single Sign-On.<br>
<br>
The token itself is a BASE-64 encoded variable length byte stream that contains a versioning header, the creation time, expiration time, the username and a SHA-1 hash of the preceding data concatenated with the shared secret from the Web SSO Configuration.<br>
<br>
The format of the Domino Single Sign-On token is as follows:<br>
<br>
	<font size="2" face="Courier New">[token] = BASE64([header][creation time][expiration time][username][SHA-1 hash])</font><br>
<br>
Where the SHA-1 hash is taken over the token data and the shared secret: <br>
<br>
<font size="2" face="Courier New">	[SHA-1 hash] = SHA-1([header][creation time][expiration time][username][shared secret])</font><br>

<ul><b>To generate a Domino style Single Sign-On token</b><br>
<br>
1. Read the BASE-64 encoded secret data from the <b>LTPA_DominoSecret</b> field of the Web SSO Configuration.<br>
2. Read the expiration interval from the<font color="#0000FF"> </font><b>LTPA_TokenExpiration</b> field of the Web SSO Configuration.<br>
2. Begin with the 4 bytes of versioning header information.
<ul>- Version 0 is <font size="2" face="Courier New">[0x00][0x01][0x02][0x03]</font></ul>
3. Append the creation time.
<ul>- Creation time is represented as an offset in seconds from 1/1/1970 12:00 GMT.<br>
- It is encoded as an 8 character hexadecimal string. Use printf() with the %08x modifier.</ul>
4. Append the expiration time.
<ul>- Expiration time is also represented as an offset in seconds from 1/1/1970 12:00 GMT.<br>
- It is encoded as a 8 character hexadecimal string. Use printf() with the %08x modifier.</ul>
5. Append the Username.
<ul>- There is no restriction on the format of the Username, but the LMBCS fully labeled canonical name is recommended, with a maximum length of MAXUSERNAME.</ul>
6. Generate a SHA-1 hash (20 bytes) over the data that has been concatenated plus the 20 byte shared secret.<br>
7. Append the SHA-1 hash after the Username.<br>
8. BASE-64 encode the final token.<br>
<br>
<b>To validate a Domino style Single Sign-On token</b><br>
<br>
1. Read the BASE-64 encoded secret data from the <b>LTPA_DominoSecret</b> field of the Web SSO Configuration.<br>
2. BASE-64 decode the token to its raw bytes.<br>
3. Calculate the length of the variable length data for the username. 
<ul>- variable_length = total_length - immutable_length (40 bytes)<br>
- The variable_length part of the token must be &gt; 0. If not, the token is invalid.</ul>
4. Verify the integrity of the token by checking the hash.
<ul>- Generate a SHA-1 hash over the token (excluding the hash contained in the token) and the 20 byte shared secret.<br>
- Compare this hash to the one contained in the token. If they match, then the token is valid.</ul>
5. Parse the first 4 bytes of header information.
<ul>- Version 0 is <font size="2" face="Courier New">[0x00][0x01][0x02][0x03]</font></ul>
6. Parse the creation time.<br>
7. Parse and enforce the token expiration time.<br>
8. Parse the Username.<br>
</ul>
<b><font size="5" color="#000080">Debugging Single Sign-On</font></b><br>
<br>
There is a debug NOTES.INI variable that is available to assist in tracing down problems with the encoding and decoding of Single Sign-On tokens. Set DEBUG_SSO_TRACE_LEVEL=1 to get information as the Web SSO Configuration is retrieved, and also as tokens are encoded and decoded. Set DEBUG_SSO_TRACE_LEVEL=2 to get more verbose memory dumps as tokens are encoded and decoded.
---
